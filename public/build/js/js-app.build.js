/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		2: 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "js/" + ({"0":"bouncer-validation"}[chunkId]||chunkId) + ".build.js?v=" + "c09f72" + ""
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// JSONP chunk loading for javascript
/******/
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData !== 0) { // 0 means "already installed".
/******/
/******/ 			// a Promise means "currently loading".
/******/ 			if(installedChunkData) {
/******/ 				promises.push(installedChunkData[2]);
/******/ 			} else {
/******/ 				// setup Promise in chunk cache
/******/ 				var promise = new Promise(function(resolve, reject) {
/******/ 					installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 				});
/******/ 				promises.push(installedChunkData[2] = promise);
/******/
/******/ 				// start chunk loading
/******/ 				var script = document.createElement('script');
/******/ 				var onScriptComplete;
/******/
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.src = jsonpScriptSrc(chunkId);
/******/
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				onScriptComplete = function (event) {
/******/ 					// avoid mem leaks in IE.
/******/ 					script.onerror = script.onload = null;
/******/ 					clearTimeout(timeout);
/******/ 					var chunk = installedChunks[chunkId];
/******/ 					if(chunk !== 0) {
/******/ 						if(chunk) {
/******/ 							var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 							var realSrc = event && event.target && event.target.src;
/******/ 							error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 							error.name = 'ChunkLoadError';
/******/ 							error.type = errorType;
/******/ 							error.request = realSrc;
/******/ 							chunk[1](error);
/******/ 						}
/******/ 						installedChunks[chunkId] = undefined;
/******/ 					}
/******/ 				};
/******/ 				var timeout = setTimeout(function(){
/******/ 					onScriptComplete({ type: 'timeout', target: script });
/******/ 				}, 120000);
/******/ 				script.onerror = script.onload = onScriptComplete;
/******/ 				document.head.appendChild(script);
/******/ 			}
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/svgxuse/svgxuse.js\nvar svgxuse = __webpack_require__(3);\n\n// CONCATENATED MODULE: ./assets/js/tests/is-storage-supported.js\n/**\r\n * Check if local- or sessionstorage is available\r\n * @param storage\r\n * @returns {boolean}\r\n */\nvar isStorageSupported = function isStorageSupported(storage) {\n  try {\n    var storageObject = window[\"\".concat(storage, \"Storage\")];\n    var testKey = 'test';\n    storageObject.setItem(testKey, '1');\n    storageObject.removeItem(testKey);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\n/* harmony default export */ var is_storage_supported = (isStorageSupported);\n// CONCATENATED MODULE: ./assets/js/tests/is-touch-device.js\n/**\r\n * Useful environment variable to see if we're dealing with a touch device\r\n *\r\n * @type {Boolean}\r\n */\nvar isTouchDevice = function isTouchDevice() {\n  var msGesture = window.navigator && window.navigator.msMaxTouchPoints && window.MSGesture;\n  var touch = ('ontouchstart' in window || msGesture || window.DocumentTouch) && document instanceof window.DocumentTouch;\n  return !!touch;\n};\n\n/* harmony default export */ var is_touch_device = (isTouchDevice);\n// CONCATENATED MODULE: ./assets/js/helpers/screenwidth-in-em.js\n/**\r\n * Return window.innerwidth in <em> format based on font-size\r\n *\r\n * @returns {number}\r\n */\nvar screenWidthEm = function screenWidthEm() {\n  return window.innerWidth / parseFloat(getComputedStyle(document.querySelector('body'))['font-size']);\n};\n\n/* harmony default export */ var screenwidth_in_em = (screenWidthEm);\n// CONCATENATED MODULE: ./assets/js/helpers/browser-storage.js\n/* global app */\nvar storage = function storage(method) {\n  if (method === 'local') {\n    if (app.test.isLocalStorageSupported) {\n      return window.localStorage;\n    }\n  } else if (app.test.isSessionStorageSupported) {\n    return window.sessionStorage;\n  }\n\n  return {\n    data: {},\n    setItem: function setItem(id, val) {\n      this.data[id] = String(val);\n      return this.data[id];\n    },\n    getItem: function getItem(id) {\n      return Object.prototype.hasOwnProperty.call(this.data, id) ? this.data[id] : undefined;\n    },\n    removeItem: function removeItem(id) {\n      return delete this.data[id];\n    },\n    clear: function clear() {\n      this.data = {};\n      return this.data;\n    }\n  };\n};\n\n/* harmony default export */ var browser_storage = (storage);\n// CONCATENATED MODULE: ./assets/js/helpers/cookies/set-cookie.js\n/**\r\n * Set a JS cookie\r\n *\r\n * @param name\r\n * @param value\r\n * @param days\r\n * @param url\r\n */\nvar setCookie = function setCookie(name, value, days, url) {\n  if (!name || !value) {\n    return;\n  }\n\n  var expires;\n  var domain;\n\n  if (days) {\n    var date = new Date();\n    date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);\n    expires = \"; expires=\".concat(date.toGMTString());\n  } else {\n    expires = '';\n  }\n\n  if (url) {\n    domain = \"; domain=\".concat(url);\n  } else {\n    domain = '';\n  }\n\n  document.cookie = \"\".concat(name, \"=\").concat(value).concat(expires, \"; path=/\").concat(domain);\n};\n\n/* harmony default export */ var set_cookie = (setCookie);\n// CONCATENATED MODULE: ./assets/js/helpers/cookies/get-cookie.js\n/**\r\n * Read cookie value from given cookiename\r\n * @param name\r\n * @returns {string|null}\r\n */\nvar getCookie = function getCookie(name) {\n  var nameEQ = \"\".concat(name, \"=\");\n  var ca = document.cookie.split(';');\n\n  for (var i = 0; i < ca.length; i + 1) {\n    var c = ca[i];\n\n    while (c.charAt(0) === ' ') {\n      c = c.substring(1, c.length);\n    }\n\n    if (c.indexOf(nameEQ) === 0) {\n      return c.substring(nameEQ.length, c.length);\n    }\n  }\n\n  return null;\n};\n\n/* harmony default export */ var get_cookie = (getCookie);\n// CONCATENATED MODULE: ./assets/js/helpers/cookies/remove-cookie.js\nvar removeCookie = function removeCookie(name) {\n  if (!name) {\n    return;\n  }\n\n  document.cookie = \"\".concat(name, \" =; expires=Thu, 01 Jan 1970 00:00:01 GMT;\");\n};\n\n/* harmony default export */ var remove_cookie = (removeCookie);\n// CONCATENATED MODULE: ./assets/js/helpers/class-attributes/has-class.js\nvar hasClass = function hasClass(element, classname) {\n  return \" \".concat(element.className, \" \").indexOf(\" \".concat(classname, \" \")) > -1;\n};\n\n/* harmony default export */ var has_class = (hasClass);\n// CONCATENATED MODULE: ./assets/js/helpers/class-attributes/add-class.js\n/* eslint no-param-reassign: [\"error\", { \"props\": false }] */\n\n\nvar add_class_addClass = function addClass(element, classname) {\n  if (!element) {\n    return;\n  }\n\n  if (!has_class(element, classname)) {\n    element.className += \" \".concat(classname);\n  }\n};\n\n/* harmony default export */ var add_class = (add_class_addClass);\n// CONCATENATED MODULE: ./assets/js/helpers/class-attributes/remove-class.js\n/* eslint no-param-reassign: [\"error\", { \"props\": false }] */\n\n\nvar remove_class_removeClass = function removeClass(element, classname) {\n  if (has_class(element, classname)) {\n    var reg = new RegExp(\"(\\\\s|^)\".concat(classname, \"(\\\\s|$)\"));\n    element.className = element.className.replace(reg, ' ');\n  }\n};\n\n/* harmony default export */ var remove_class = (remove_class_removeClass);\n// CONCATENATED MODULE: ./assets/js/helpers/class-attributes/toggle-class.js\n\n\n\n\nvar toggle_class_toggleClass = function toggleClass(element, classname) {\n  if (has_class(element, classname)) {\n    remove_class(element, classname);\n  } else {\n    add_class(element, classname);\n  }\n};\n\n/* harmony default export */ var toggle_class = (toggle_class_toggleClass);\n// CONCATENATED MODULE: ./assets/js/helpers/class-attributes/_class-attributes.js\n\n\n\n\nwindow.hasClass = has_class;\nwindow.addClass = add_class;\nwindow.removeClass = remove_class;\nwindow.toggleClass = toggle_class;\n// CONCATENATED MODULE: ./assets/js/modules/form/load-validation.js\nvar _this = undefined;\n\nvar loadValidation = function loadValidation() {\n  return new Promise(function (resolve, reject) {\n    __webpack_require__.e(/* import() | bouncer-validation */ 0).then(__webpack_require__.t.bind(null, 12, 7)).then(function (fn) {\n      window.Bouncer = fn.default;\n\n      if (typeof window.Bouncer === 'function') {\n        resolve(_this);\n      } else {\n        reject(Error('can\\'t load Bouncer...'));\n      }\n    });\n  });\n};\n\n/* harmony default export */ var load_validation = (loadValidation);\n// CONCATENATED MODULE: ./assets/js/modules/form/validation-messages.js\n/* harmony default export */ var validation_messages = ({\n  missingValue: {\n    checkbox: 'Dit veld is verplicht.',\n    radio: 'Selecteer een waarde.',\n    select: 'Selecteer een waarde.',\n    'select-multiple': 'Kies een waarde.',\n    default: 'Dit veld is niet (correct) ingevuld.'\n  },\n  patternMismatch: {\n    email: 'Vul een geldig e-mailadres in.',\n    url: 'Vul een geldige url in.',\n    number: 'Vul een nummer in.',\n    color: 'Kleuren moeten deze notatie hebben: #rrggbb.',\n    date: 'Gebruik het datumformat: YYYY-MM-DD.',\n    time: 'Gebruik het 24 uur tijdformaat: Bijvoorbeeld 23:00.',\n    month: 'Gebruik het datumformat: YYYY-MM.',\n    password: 'Het wachtwoord voldoet niet aan de eisen.',\n    default: 'Gebruik het juiste format.'\n  },\n  outOfRange: {\n    over: 'Kies een waarde lager dan {max}.',\n    under: 'Kies een waarde hoger dan {min}.'\n  },\n  wrongLength: {\n    over: 'Sorry. Je hebt teveel karakters gebruikt. Je gebruikt nu {length} karakters en er is een maximum van {maxLength}.',\n    under: 'In dit veld zijn er minimaal {minLength} karakters nodig. Je gebruikt nu {length} karakters.'\n  }\n});\n// CONCATENATED MODULE: ./assets/js/modules/form/form-validation.js\n/* global Bouncer */\n\n\nvar formClassSelector = '.js-form-validate';\nvar form_validation_form = document.querySelector(formClassSelector);\n/*\r\n * Validate the form\r\n */\n\nvar form_validation_validate = function validate() {\n  return new Bouncer(formClassSelector, {\n    fieldClass: 'form__input--error',\n    errorClass: 'form__error',\n    messages: validation_messages\n  });\n};\n\nvar form_validation_init = function init() {\n  if (!form_validation_form) {\n    return;\n  } // Init the validation after loading bouncer\n\n\n  load_validation().then(function () {\n    form_validation_validate();\n  });\n};\n\n/* harmony default export */ var form_validation = (form_validation_init);\n// CONCATENATED MODULE: ./assets/js/app.js\n/* global app */\n\n/* eslint-disable import/first */\n// Apply SVG polyfill to load external SVG's in unsupported browsers\n // Tests\n\n\n // Helpers\n\n\n\n\n\n // Make class attributes in window available\n\n // Init Form validation\n\n\n/* eslint-enable import/first */\n\n/**\r\n * Set in site or modules used config elements\r\n */\n\napp.config = {\n  breakpoints: {\n    sm: 30,\n    md: 40,\n    lg: 60,\n    xl: 74,\n    hamburger: 60\n  }\n};\n/**\r\n * Test some browser options and make them available in app.test\r\n */\n\napp.test = {\n  isEnvironmentIsDev: window.location.host.indexOf('.ebox') > -1,\n  isEnvironmentIsTest: window.location.host.indexOf('.tdebv.nl') > -1,\n  isSessionStorageSupported: is_storage_supported('session'),\n  isLocalStorageSupported: is_storage_supported('local'),\n  isTouchDevice: is_touch_device()\n};\n/**\r\n * Add some handy helper functions\r\n */\n\napp.helper = {\n  giveScreenWidth: screenwidth_in_em,\n  localStorage: browser_storage('local'),\n  sessionStorage: browser_storage('session'),\n  setCookie: set_cookie,\n  getCookie: get_cookie,\n  removeCookie: remove_cookie\n};\nform_validation();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2Fzc2V0cy9qcy90ZXN0cy9pcy1zdG9yYWdlLXN1cHBvcnRlZC5qcz8yZmJlIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy90ZXN0cy9pcy10b3VjaC1kZXZpY2UuanM/NzAzNyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvaGVscGVycy9zY3JlZW53aWR0aC1pbi1lbS5qcz9kMmMxIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9oZWxwZXJzL2Jyb3dzZXItc3RvcmFnZS5qcz8yNjhmIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9oZWxwZXJzL2Nvb2tpZXMvc2V0LWNvb2tpZS5qcz80N2UxIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9oZWxwZXJzL2Nvb2tpZXMvZ2V0LWNvb2tpZS5qcz8wZTI5Iiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9oZWxwZXJzL2Nvb2tpZXMvcmVtb3ZlLWNvb2tpZS5qcz81NTE1Iiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9oZWxwZXJzL2NsYXNzLWF0dHJpYnV0ZXMvaGFzLWNsYXNzLmpzPzY0YmMiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2hlbHBlcnMvY2xhc3MtYXR0cmlidXRlcy9hZGQtY2xhc3MuanM/YWY4MyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvaGVscGVycy9jbGFzcy1hdHRyaWJ1dGVzL3JlbW92ZS1jbGFzcy5qcz8yMDdhIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9oZWxwZXJzL2NsYXNzLWF0dHJpYnV0ZXMvdG9nZ2xlLWNsYXNzLmpzPzM3ZWIiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2hlbHBlcnMvY2xhc3MtYXR0cmlidXRlcy9fY2xhc3MtYXR0cmlidXRlcy5qcz8yMTI5Iiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9tb2R1bGVzL2Zvcm0vbG9hZC12YWxpZGF0aW9uLmpzPzUxZjciLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL21vZHVsZXMvZm9ybS92YWxpZGF0aW9uLW1lc3NhZ2VzLmpzPzBlZWYiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL21vZHVsZXMvZm9ybS9mb3JtLXZhbGlkYXRpb24uanM/N2ZhYyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvYXBwLmpzP2RiMmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENoZWNrIGlmIGxvY2FsLSBvciBzZXNzaW9uc3RvcmFnZSBpcyBhdmFpbGFibGVcclxuICogQHBhcmFtIHN0b3JhZ2VcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xudmFyIGlzU3RvcmFnZVN1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3RvcmFnZVN1cHBvcnRlZChzdG9yYWdlKSB7XG4gIHRyeSB7XG4gICAgdmFyIHN0b3JhZ2VPYmplY3QgPSB3aW5kb3dbXCJcIi5jb25jYXQoc3RvcmFnZSwgXCJTdG9yYWdlXCIpXTtcbiAgICB2YXIgdGVzdEtleSA9ICd0ZXN0JztcbiAgICBzdG9yYWdlT2JqZWN0LnNldEl0ZW0odGVzdEtleSwgJzEnKTtcbiAgICBzdG9yYWdlT2JqZWN0LnJlbW92ZUl0ZW0odGVzdEtleSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBpc1N0b3JhZ2VTdXBwb3J0ZWQ7IiwiLyoqXHJcbiAqIFVzZWZ1bCBlbnZpcm9ubWVudCB2YXJpYWJsZSB0byBzZWUgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEgdG91Y2ggZGV2aWNlXHJcbiAqXHJcbiAqIEB0eXBlIHtCb29sZWFufVxyXG4gKi9cbnZhciBpc1RvdWNoRGV2aWNlID0gZnVuY3Rpb24gaXNUb3VjaERldmljZSgpIHtcbiAgdmFyIG1zR2VzdHVyZSA9IHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzICYmIHdpbmRvdy5NU0dlc3R1cmU7XG4gIHZhciB0b3VjaCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgbXNHZXN0dXJlIHx8IHdpbmRvdy5Eb2N1bWVudFRvdWNoKSAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoO1xuICByZXR1cm4gISF0b3VjaDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlzVG91Y2hEZXZpY2U7IiwiLyoqXHJcbiAqIFJldHVybiB3aW5kb3cuaW5uZXJ3aWR0aCBpbiA8ZW0+IGZvcm1hdCBiYXNlZCBvbiBmb250LXNpemVcclxuICpcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXG52YXIgc2NyZWVuV2lkdGhFbSA9IGZ1bmN0aW9uIHNjcmVlbldpZHRoRW0oKSB7XG4gIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aCAvIHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JykpWydmb250LXNpemUnXSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzY3JlZW5XaWR0aEVtOyIsIi8qIGdsb2JhbCBhcHAgKi9cbnZhciBzdG9yYWdlID0gZnVuY3Rpb24gc3RvcmFnZShtZXRob2QpIHtcbiAgaWYgKG1ldGhvZCA9PT0gJ2xvY2FsJykge1xuICAgIGlmIChhcHAudGVzdC5pc0xvY2FsU3RvcmFnZVN1cHBvcnRlZCkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFwcC50ZXN0LmlzU2Vzc2lvblN0b3JhZ2VTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gd2luZG93LnNlc3Npb25TdG9yYWdlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiB7fSxcbiAgICBzZXRJdGVtOiBmdW5jdGlvbiBzZXRJdGVtKGlkLCB2YWwpIHtcbiAgICAgIHRoaXMuZGF0YVtpZF0gPSBTdHJpbmcodmFsKTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFbaWRdO1xuICAgIH0sXG4gICAgZ2V0SXRlbTogZnVuY3Rpb24gZ2V0SXRlbShpZCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmRhdGEsIGlkKSA/IHRoaXMuZGF0YVtpZF0gOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICByZW1vdmVJdGVtOiBmdW5jdGlvbiByZW1vdmVJdGVtKGlkKSB7XG4gICAgICByZXR1cm4gZGVsZXRlIHRoaXMuZGF0YVtpZF07XG4gICAgfSxcbiAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc3RvcmFnZTsiLCIvKipcclxuICogU2V0IGEgSlMgY29va2llXHJcbiAqXHJcbiAqIEBwYXJhbSBuYW1lXHJcbiAqIEBwYXJhbSB2YWx1ZVxyXG4gKiBAcGFyYW0gZGF5c1xyXG4gKiBAcGFyYW0gdXJsXHJcbiAqL1xudmFyIHNldENvb2tpZSA9IGZ1bmN0aW9uIHNldENvb2tpZShuYW1lLCB2YWx1ZSwgZGF5cywgdXJsKSB7XG4gIGlmICghbmFtZSB8fCAhdmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXhwaXJlcztcbiAgdmFyIGRvbWFpbjtcblxuICBpZiAoZGF5cykge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcbiAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyBkYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCk7XG4gICAgZXhwaXJlcyA9IFwiOyBleHBpcmVzPVwiLmNvbmNhdChkYXRlLnRvR01UU3RyaW5nKCkpO1xuICB9IGVsc2Uge1xuICAgIGV4cGlyZXMgPSAnJztcbiAgfVxuXG4gIGlmICh1cmwpIHtcbiAgICBkb21haW4gPSBcIjsgZG9tYWluPVwiLmNvbmNhdCh1cmwpO1xuICB9IGVsc2Uge1xuICAgIGRvbWFpbiA9ICcnO1xuICB9XG5cbiAgZG9jdW1lbnQuY29va2llID0gXCJcIi5jb25jYXQobmFtZSwgXCI9XCIpLmNvbmNhdCh2YWx1ZSkuY29uY2F0KGV4cGlyZXMsIFwiOyBwYXRoPS9cIikuY29uY2F0KGRvbWFpbik7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzZXRDb29raWU7IiwiLyoqXHJcbiAqIFJlYWQgY29va2llIHZhbHVlIGZyb20gZ2l2ZW4gY29va2llbmFtZVxyXG4gKiBAcGFyYW0gbmFtZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9XHJcbiAqL1xudmFyIGdldENvb2tpZSA9IGZ1bmN0aW9uIGdldENvb2tpZShuYW1lKSB7XG4gIHZhciBuYW1lRVEgPSBcIlwiLmNvbmNhdChuYW1lLCBcIj1cIik7XG4gIHZhciBjYSA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2EubGVuZ3RoOyBpICsgMSkge1xuICAgIHZhciBjID0gY2FbaV07XG5cbiAgICB3aGlsZSAoYy5jaGFyQXQoMCkgPT09ICcgJykge1xuICAgICAgYyA9IGMuc3Vic3RyaW5nKDEsIGMubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBpZiAoYy5pbmRleE9mKG5hbWVFUSkgPT09IDApIHtcbiAgICAgIHJldHVybiBjLnN1YnN0cmluZyhuYW1lRVEubGVuZ3RoLCBjLmxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBnZXRDb29raWU7IiwidmFyIHJlbW92ZUNvb2tpZSA9IGZ1bmN0aW9uIHJlbW92ZUNvb2tpZShuYW1lKSB7XG4gIGlmICghbmFtZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRvY3VtZW50LmNvb2tpZSA9IFwiXCIuY29uY2F0KG5hbWUsIFwiID07IGV4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMSBHTVQ7XCIpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgcmVtb3ZlQ29va2llOyIsInZhciBoYXNDbGFzcyA9IGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzbmFtZSkge1xuICByZXR1cm4gXCIgXCIuY29uY2F0KGVsZW1lbnQuY2xhc3NOYW1lLCBcIiBcIikuaW5kZXhPZihcIiBcIi5jb25jYXQoY2xhc3NuYW1lLCBcIiBcIikpID4gLTE7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBoYXNDbGFzczsiLCIvKiBlc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246IFtcImVycm9yXCIsIHsgXCJwcm9wc1wiOiBmYWxzZSB9XSAqL1xuaW1wb3J0IGhhc0NsYXNzIGZyb20gJy4vaGFzLWNsYXNzJztcblxudmFyIGFkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NuYW1lKSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NuYW1lKSkge1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IFwiIFwiLmNvbmNhdChjbGFzc25hbWUpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBhZGRDbGFzczsiLCIvKiBlc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246IFtcImVycm9yXCIsIHsgXCJwcm9wc1wiOiBmYWxzZSB9XSAqL1xuaW1wb3J0IGhhc0NsYXNzIGZyb20gJy4vaGFzLWNsYXNzJztcblxudmFyIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NuYW1lKSB7XG4gIGlmIChoYXNDbGFzcyhlbGVtZW50LCBjbGFzc25hbWUpKSB7XG4gICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoXCIoXFxcXHN8XilcIi5jb25jYXQoY2xhc3NuYW1lLCBcIihcXFxcc3wkKVwiKSk7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKHJlZywgJyAnKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgcmVtb3ZlQ2xhc3M7IiwiaW1wb3J0IGhhc0NsYXNzIGZyb20gJy4vaGFzLWNsYXNzJztcbmltcG9ydCByZW1vdmVDbGFzcyBmcm9tICcuL3JlbW92ZS1jbGFzcyc7XG5pbXBvcnQgYWRkQ2xhc3MgZnJvbSAnLi9hZGQtY2xhc3MnO1xuXG52YXIgdG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbiB0b2dnbGVDbGFzcyhlbGVtZW50LCBjbGFzc25hbWUpIHtcbiAgaWYgKGhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzbmFtZSkpIHtcbiAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc25hbWUpO1xuICB9IGVsc2Uge1xuICAgIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzbmFtZSk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHRvZ2dsZUNsYXNzOyIsImltcG9ydCBoYXNDbGFzcyBmcm9tICcuL2hhcy1jbGFzcyc7XG5pbXBvcnQgYWRkQ2xhc3MgZnJvbSAnLi9hZGQtY2xhc3MnO1xuaW1wb3J0IHJlbW92ZUNsYXNzIGZyb20gJy4vcmVtb3ZlLWNsYXNzJztcbmltcG9ydCB0b2dnbGVDbGFzcyBmcm9tICcuL3RvZ2dsZS1jbGFzcyc7XG53aW5kb3cuaGFzQ2xhc3MgPSBoYXNDbGFzcztcbndpbmRvdy5hZGRDbGFzcyA9IGFkZENsYXNzO1xud2luZG93LnJlbW92ZUNsYXNzID0gcmVtb3ZlQ2xhc3M7XG53aW5kb3cudG9nZ2xlQ2xhc3MgPSB0b2dnbGVDbGFzczsiLCJ2YXIgX3RoaXMgPSB0aGlzO1xuXG52YXIgbG9hZFZhbGlkYXRpb24gPSBmdW5jdGlvbiBsb2FkVmFsaWRhdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpbXBvcnQoJ2Zvcm1ib3VuY2VyanMnXG4gICAgLyogd2VicGFja0NodW5rTmFtZTogXCJib3VuY2VyLXZhbGlkYXRpb25cIiAqL1xuICAgICkudGhlbihmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHdpbmRvdy5Cb3VuY2VyID0gZm4uZGVmYXVsdDtcblxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuQm91bmNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXNvbHZlKF90aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChFcnJvcignY2FuXFwndCBsb2FkIEJvdW5jZXIuLi4nKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbG9hZFZhbGlkYXRpb247IiwiZXhwb3J0IGRlZmF1bHQge1xuICBtaXNzaW5nVmFsdWU6IHtcbiAgICBjaGVja2JveDogJ0RpdCB2ZWxkIGlzIHZlcnBsaWNodC4nLFxuICAgIHJhZGlvOiAnU2VsZWN0ZWVyIGVlbiB3YWFyZGUuJyxcbiAgICBzZWxlY3Q6ICdTZWxlY3RlZXIgZWVuIHdhYXJkZS4nLFxuICAgICdzZWxlY3QtbXVsdGlwbGUnOiAnS2llcyBlZW4gd2FhcmRlLicsXG4gICAgZGVmYXVsdDogJ0RpdCB2ZWxkIGlzIG5pZXQgKGNvcnJlY3QpIGluZ2V2dWxkLidcbiAgfSxcbiAgcGF0dGVybk1pc21hdGNoOiB7XG4gICAgZW1haWw6ICdWdWwgZWVuIGdlbGRpZyBlLW1haWxhZHJlcyBpbi4nLFxuICAgIHVybDogJ1Z1bCBlZW4gZ2VsZGlnZSB1cmwgaW4uJyxcbiAgICBudW1iZXI6ICdWdWwgZWVuIG51bW1lciBpbi4nLFxuICAgIGNvbG9yOiAnS2xldXJlbiBtb2V0ZW4gZGV6ZSBub3RhdGllIGhlYmJlbjogI3JyZ2diYi4nLFxuICAgIGRhdGU6ICdHZWJydWlrIGhldCBkYXR1bWZvcm1hdDogWVlZWS1NTS1ERC4nLFxuICAgIHRpbWU6ICdHZWJydWlrIGhldCAyNCB1dXIgdGlqZGZvcm1hYXQ6IEJpanZvb3JiZWVsZCAyMzowMC4nLFxuICAgIG1vbnRoOiAnR2VicnVpayBoZXQgZGF0dW1mb3JtYXQ6IFlZWVktTU0uJyxcbiAgICBwYXNzd29yZDogJ0hldCB3YWNodHdvb3JkIHZvbGRvZXQgbmlldCBhYW4gZGUgZWlzZW4uJyxcbiAgICBkZWZhdWx0OiAnR2VicnVpayBoZXQganVpc3RlIGZvcm1hdC4nXG4gIH0sXG4gIG91dE9mUmFuZ2U6IHtcbiAgICBvdmVyOiAnS2llcyBlZW4gd2FhcmRlIGxhZ2VyIGRhbiB7bWF4fS4nLFxuICAgIHVuZGVyOiAnS2llcyBlZW4gd2FhcmRlIGhvZ2VyIGRhbiB7bWlufS4nXG4gIH0sXG4gIHdyb25nTGVuZ3RoOiB7XG4gICAgb3ZlcjogJ1NvcnJ5LiBKZSBoZWJ0IHRldmVlbCBrYXJha3RlcnMgZ2VicnVpa3QuIEplIGdlYnJ1aWt0IG51IHtsZW5ndGh9IGthcmFrdGVycyBlbiBlciBpcyBlZW4gbWF4aW11bSB2YW4ge21heExlbmd0aH0uJyxcbiAgICB1bmRlcjogJ0luIGRpdCB2ZWxkIHppam4gZXIgbWluaW1hYWwge21pbkxlbmd0aH0ga2FyYWt0ZXJzIG5vZGlnLiBKZSBnZWJydWlrdCBudSB7bGVuZ3RofSBrYXJha3RlcnMuJ1xuICB9XG59OyIsIi8qIGdsb2JhbCBCb3VuY2VyICovXG5pbXBvcnQgbG9hZFZhbGlkYXRpb24gZnJvbSAnLi9sb2FkLXZhbGlkYXRpb24nO1xuaW1wb3J0IHZhbGlkYXRpb25NZXNzYWdlcyBmcm9tICcuL3ZhbGlkYXRpb24tbWVzc2FnZXMnO1xudmFyIGZvcm1DbGFzc1NlbGVjdG9yID0gJy5qcy1mb3JtLXZhbGlkYXRlJztcbnZhciBmb3JtID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihmb3JtQ2xhc3NTZWxlY3Rvcik7XG4vKlxyXG4gKiBWYWxpZGF0ZSB0aGUgZm9ybVxyXG4gKi9cblxudmFyIHZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHJldHVybiBuZXcgQm91bmNlcihmb3JtQ2xhc3NTZWxlY3Rvciwge1xuICAgIGZpZWxkQ2xhc3M6ICdmb3JtX19pbnB1dC0tZXJyb3InLFxuICAgIGVycm9yQ2xhc3M6ICdmb3JtX19lcnJvcicsXG4gICAgbWVzc2FnZXM6IHZhbGlkYXRpb25NZXNzYWdlc1xuICB9KTtcbn07XG5cbnZhciBpbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgaWYgKCFmb3JtKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIEluaXQgdGhlIHZhbGlkYXRpb24gYWZ0ZXIgbG9hZGluZyBib3VuY2VyXG5cblxuICBsb2FkVmFsaWRhdGlvbigpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHZhbGlkYXRlKCk7XG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaW5pdDsiLCIvKiBnbG9iYWwgYXBwICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9maXJzdCAqL1xuLy8gQXBwbHkgU1ZHIHBvbHlmaWxsIHRvIGxvYWQgZXh0ZXJuYWwgU1ZHJ3MgaW4gdW5zdXBwb3J0ZWQgYnJvd3NlcnNcbmltcG9ydCAnc3ZneHVzZSc7IC8vIFRlc3RzXG5cbmltcG9ydCBzdG9yYWdlVGVzdHMgZnJvbSAnLi90ZXN0cy9pcy1zdG9yYWdlLXN1cHBvcnRlZCc7XG5pbXBvcnQgdG91Y2hUZXN0cyBmcm9tICcuL3Rlc3RzL2lzLXRvdWNoLWRldmljZSc7IC8vIEhlbHBlcnNcblxuaW1wb3J0IHNjcmVlbldpZHRoSGVscGVyIGZyb20gJy4vaGVscGVycy9zY3JlZW53aWR0aC1pbi1lbSc7XG5pbXBvcnQgYnJvd3NlclN0b3JhZ2VIZWxwZXIgZnJvbSAnLi9oZWxwZXJzL2Jyb3dzZXItc3RvcmFnZSc7XG5pbXBvcnQgc2V0Q29va2llSGVscGVyIGZyb20gJy4vaGVscGVycy9jb29raWVzL3NldC1jb29raWUnO1xuaW1wb3J0IGdldENvb2tpZUhlbHBlciBmcm9tICcuL2hlbHBlcnMvY29va2llcy9nZXQtY29va2llJztcbmltcG9ydCByZW1vdmVDb29raWVIZWxwZXIgZnJvbSAnLi9oZWxwZXJzL2Nvb2tpZXMvcmVtb3ZlLWNvb2tpZSc7IC8vIE1ha2UgY2xhc3MgYXR0cmlidXRlcyBpbiB3aW5kb3cgYXZhaWxhYmxlXG5cbmltcG9ydCAnLi9oZWxwZXJzL2NsYXNzLWF0dHJpYnV0ZXMvX2NsYXNzLWF0dHJpYnV0ZXMnOyAvLyBJbml0IEZvcm0gdmFsaWRhdGlvblxuXG5pbXBvcnQgZm9ybVZhbGlkYXRlIGZyb20gJy4vbW9kdWxlcy9mb3JtL2Zvcm0tdmFsaWRhdGlvbic7XG4vKiBlc2xpbnQtZW5hYmxlIGltcG9ydC9maXJzdCAqL1xuXG4vKipcclxuICogU2V0IGluIHNpdGUgb3IgbW9kdWxlcyB1c2VkIGNvbmZpZyBlbGVtZW50c1xyXG4gKi9cblxuYXBwLmNvbmZpZyA9IHtcbiAgYnJlYWtwb2ludHM6IHtcbiAgICBzbTogMzAsXG4gICAgbWQ6IDQwLFxuICAgIGxnOiA2MCxcbiAgICB4bDogNzQsXG4gICAgaGFtYnVyZ2VyOiA2MFxuICB9XG59O1xuLyoqXHJcbiAqIFRlc3Qgc29tZSBicm93c2VyIG9wdGlvbnMgYW5kIG1ha2UgdGhlbSBhdmFpbGFibGUgaW4gYXBwLnRlc3RcclxuICovXG5cbmFwcC50ZXN0ID0ge1xuICBpc0Vudmlyb25tZW50SXNEZXY6IHdpbmRvdy5sb2NhdGlvbi5ob3N0LmluZGV4T2YoJy5lYm94JykgPiAtMSxcbiAgaXNFbnZpcm9ubWVudElzVGVzdDogd2luZG93LmxvY2F0aW9uLmhvc3QuaW5kZXhPZignLnRkZWJ2Lm5sJykgPiAtMSxcbiAgaXNTZXNzaW9uU3RvcmFnZVN1cHBvcnRlZDogc3RvcmFnZVRlc3RzKCdzZXNzaW9uJyksXG4gIGlzTG9jYWxTdG9yYWdlU3VwcG9ydGVkOiBzdG9yYWdlVGVzdHMoJ2xvY2FsJyksXG4gIGlzVG91Y2hEZXZpY2U6IHRvdWNoVGVzdHMoKVxufTtcbi8qKlxyXG4gKiBBZGQgc29tZSBoYW5keSBoZWxwZXIgZnVuY3Rpb25zXHJcbiAqL1xuXG5hcHAuaGVscGVyID0ge1xuICBnaXZlU2NyZWVuV2lkdGg6IHNjcmVlbldpZHRoSGVscGVyLFxuICBsb2NhbFN0b3JhZ2U6IGJyb3dzZXJTdG9yYWdlSGVscGVyKCdsb2NhbCcpLFxuICBzZXNzaW9uU3RvcmFnZTogYnJvd3NlclN0b3JhZ2VIZWxwZXIoJ3Nlc3Npb24nKSxcbiAgc2V0Q29va2llOiBzZXRDb29raWVIZWxwZXIsXG4gIGdldENvb2tpZTogZ2V0Q29va2llSGVscGVyLFxuICByZW1vdmVDb29raWU6IHJlbW92ZUNvb2tpZUhlbHBlclxufTtcbmZvcm1WYWxpZGF0ZSgpOyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */,
/* 2 */,
/* 3 */
/***/ (function(module, exports) {

eval("/*!\n * @copyright Copyright (c) 2017 IcoMoon.io\n * @license   Licensed under MIT license\n *            See https://github.com/Keyamoon/svgxuse\n * @version   1.2.6\n */\n/*jslint browser: true */\n/*global XDomainRequest, MutationObserver, window */\n(function () {\n    \"use strict\";\n    if (typeof window !== \"undefined\" && window.addEventListener) {\n        var cache = Object.create(null); // holds xhr objects to prevent multiple requests\n        var checkUseElems;\n        var tid; // timeout id\n        var debouncedCheck = function () {\n            clearTimeout(tid);\n            tid = setTimeout(checkUseElems, 100);\n        };\n        var unobserveChanges = function () {\n            return;\n        };\n        var observeChanges = function () {\n            var observer;\n            window.addEventListener(\"resize\", debouncedCheck, false);\n            window.addEventListener(\"orientationchange\", debouncedCheck, false);\n            if (window.MutationObserver) {\n                observer = new MutationObserver(debouncedCheck);\n                observer.observe(document.documentElement, {\n                    childList: true,\n                    subtree: true,\n                    attributes: true\n                });\n                unobserveChanges = function () {\n                    try {\n                        observer.disconnect();\n                        window.removeEventListener(\"resize\", debouncedCheck, false);\n                        window.removeEventListener(\"orientationchange\", debouncedCheck, false);\n                    } catch (ignore) {}\n                };\n            } else {\n                document.documentElement.addEventListener(\"DOMSubtreeModified\", debouncedCheck, false);\n                unobserveChanges = function () {\n                    document.documentElement.removeEventListener(\"DOMSubtreeModified\", debouncedCheck, false);\n                    window.removeEventListener(\"resize\", debouncedCheck, false);\n                    window.removeEventListener(\"orientationchange\", debouncedCheck, false);\n                };\n            }\n        };\n        var createRequest = function (url) {\n            // In IE 9, cross origin requests can only be sent using XDomainRequest.\n            // XDomainRequest would fail if CORS headers are not set.\n            // Therefore, XDomainRequest should only be used with cross origin requests.\n            function getOrigin(loc) {\n                var a;\n                if (loc.protocol !== undefined) {\n                    a = loc;\n                } else {\n                    a = document.createElement(\"a\");\n                    a.href = loc;\n                }\n                return a.protocol.replace(/:/g, \"\") + a.host;\n            }\n            var Request;\n            var origin;\n            var origin2;\n            if (window.XMLHttpRequest) {\n                Request = new XMLHttpRequest();\n                origin = getOrigin(location);\n                origin2 = getOrigin(url);\n                if (Request.withCredentials === undefined && origin2 !== \"\" && origin2 !== origin) {\n                    Request = XDomainRequest || undefined;\n                } else {\n                    Request = XMLHttpRequest;\n                }\n            }\n            return Request;\n        };\n        var xlinkNS = \"http://www.w3.org/1999/xlink\";\n        checkUseElems = function () {\n            var base;\n            var bcr;\n            var fallback = \"\"; // optional fallback URL in case no base path to SVG file was given and no symbol definition was found.\n            var hash;\n            var href;\n            var i;\n            var inProgressCount = 0;\n            var isHidden;\n            var Request;\n            var url;\n            var uses;\n            var xhr;\n            function observeIfDone() {\n                // If done with making changes, start watching for chagnes in DOM again\n                inProgressCount -= 1;\n                if (inProgressCount === 0) { // if all xhrs were resolved\n                    unobserveChanges(); // make sure to remove old handlers\n                    observeChanges(); // watch for changes to DOM\n                }\n            }\n            function attrUpdateFunc(spec) {\n                return function () {\n                    if (cache[spec.base] !== true) {\n                        spec.useEl.setAttributeNS(xlinkNS, \"xlink:href\", \"#\" + spec.hash);\n                        if (spec.useEl.hasAttribute(\"href\")) {\n                            spec.useEl.setAttribute(\"href\", \"#\" + spec.hash);\n                        }\n                    }\n                };\n            }\n            function onloadFunc(xhr) {\n                return function () {\n                    var body = document.body;\n                    var x = document.createElement(\"x\");\n                    var svg;\n                    xhr.onload = null;\n                    x.innerHTML = xhr.responseText;\n                    svg = x.getElementsByTagName(\"svg\")[0];\n                    if (svg) {\n                        svg.setAttribute(\"aria-hidden\", \"true\");\n                        svg.style.position = \"absolute\";\n                        svg.style.width = 0;\n                        svg.style.height = 0;\n                        svg.style.overflow = \"hidden\";\n                        body.insertBefore(svg, body.firstChild);\n                    }\n                    observeIfDone();\n                };\n            }\n            function onErrorTimeout(xhr) {\n                return function () {\n                    xhr.onerror = null;\n                    xhr.ontimeout = null;\n                    observeIfDone();\n                };\n            }\n            unobserveChanges(); // stop watching for changes to DOM\n            // find all use elements\n            uses = document.getElementsByTagName(\"use\");\n            for (i = 0; i < uses.length; i += 1) {\n                try {\n                    bcr = uses[i].getBoundingClientRect();\n                } catch (ignore) {\n                    // failed to get bounding rectangle of the use element\n                    bcr = false;\n                }\n                href = uses[i].getAttribute(\"href\")\n                        || uses[i].getAttributeNS(xlinkNS, \"href\")\n                        || uses[i].getAttribute(\"xlink:href\");\n                if (href && href.split) {\n                    url = href.split(\"#\");\n                } else {\n                    url = [\"\", \"\"];\n                }\n                base = url[0];\n                hash = url[1];\n                isHidden = bcr && bcr.left === 0 && bcr.right === 0 && bcr.top === 0 && bcr.bottom === 0;\n                if (bcr && bcr.width === 0 && bcr.height === 0 && !isHidden) {\n                    // the use element is empty\n                    // if there is a reference to an external SVG, try to fetch it\n                    // use the optional fallback URL if there is no reference to an external SVG\n                    if (fallback && !base.length && hash && !document.getElementById(hash)) {\n                        base = fallback;\n                    }\n                    if (uses[i].hasAttribute(\"href\")) {\n                        uses[i].setAttributeNS(xlinkNS, \"xlink:href\", href);\n                    }\n                    if (base.length) {\n                        // schedule updating xlink:href\n                        xhr = cache[base];\n                        if (xhr !== true) {\n                            // true signifies that prepending the SVG was not required\n                            setTimeout(attrUpdateFunc({\n                                useEl: uses[i],\n                                base: base,\n                                hash: hash\n                            }), 0);\n                        }\n                        if (xhr === undefined) {\n                            Request = createRequest(base);\n                            if (Request !== undefined) {\n                                xhr = new Request();\n                                cache[base] = xhr;\n                                xhr.onload = onloadFunc(xhr);\n                                xhr.onerror = onErrorTimeout(xhr);\n                                xhr.ontimeout = onErrorTimeout(xhr);\n                                xhr.open(\"GET\", base);\n                                xhr.send();\n                                inProgressCount += 1;\n                            }\n                        }\n                    }\n                } else {\n                    if (!isHidden) {\n                        if (cache[base] === undefined) {\n                            // remember this URL if the use element was not empty and no request was sent\n                            cache[base] = true;\n                        } else if (cache[base].onload) {\n                            // if it turns out that prepending the SVG is not necessary,\n                            // abort the in-progress xhr.\n                            cache[base].abort();\n                            delete cache[base].onload;\n                            cache[base] = true;\n                        }\n                    } else if (base.length && cache[base]) {\n                        setTimeout(attrUpdateFunc({\n                            useEl: uses[i],\n                            base: base,\n                            hash: hash\n                        }), 0);\n                    }\n                }\n            }\n            uses = \"\";\n            inProgressCount += 1;\n            observeIfDone();\n        };\n        var winLoad;\n        winLoad = function () {\n            window.removeEventListener(\"load\", winLoad, false); // to prevent memory leaks\n            tid = setTimeout(checkUseElems, 0);\n        };\n        if (document.readyState !== \"complete\") {\n            // The load event fires when all resources have finished loading, which allows detecting whether SVG use elements are empty.\n            window.addEventListener(\"load\", winLoad, false);\n        } else {\n            // No need to add a listener if the document is already loaded, initialize immediately.\n            winLoad();\n        }\n    }\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdmd4dXNlL3N2Z3h1c2UuanM/ODNlMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE3IEljb01vb24uaW9cbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9LZXlhbW9vbi9zdmd4dXNlXG4gKiBAdmVyc2lvbiAgIDEuMi42XG4gKi9cbi8qanNsaW50IGJyb3dzZXI6IHRydWUgKi9cbi8qZ2xvYmFsIFhEb21haW5SZXF1ZXN0LCBNdXRhdGlvbk9ic2VydmVyLCB3aW5kb3cgKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgLy8gaG9sZHMgeGhyIG9iamVjdHMgdG8gcHJldmVudCBtdWx0aXBsZSByZXF1ZXN0c1xuICAgICAgICB2YXIgY2hlY2tVc2VFbGVtcztcbiAgICAgICAgdmFyIHRpZDsgLy8gdGltZW91dCBpZFxuICAgICAgICB2YXIgZGVib3VuY2VkQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGlkKTtcbiAgICAgICAgICAgIHRpZCA9IHNldFRpbWVvdXQoY2hlY2tVc2VFbGVtcywgMTAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHVub2JzZXJ2ZUNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvYnNlcnZlQ2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvYnNlcnZlcjtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGRlYm91bmNlZENoZWNrLCBmYWxzZSk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIGRlYm91bmNlZENoZWNrLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAod2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGRlYm91bmNlZENoZWNrKTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB1bm9ic2VydmVDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgZGVib3VuY2VkQ2hlY2ssIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgZGVib3VuY2VkQ2hlY2ssIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NU3VidHJlZU1vZGlmaWVkXCIsIGRlYm91bmNlZENoZWNrLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdW5vYnNlcnZlQ2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01TdWJ0cmVlTW9kaWZpZWRcIiwgZGVib3VuY2VkQ2hlY2ssIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgZGVib3VuY2VkQ2hlY2ssIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCBkZWJvdW5jZWRDaGVjaywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgLy8gSW4gSUUgOSwgY3Jvc3Mgb3JpZ2luIHJlcXVlc3RzIGNhbiBvbmx5IGJlIHNlbnQgdXNpbmcgWERvbWFpblJlcXVlc3QuXG4gICAgICAgICAgICAvLyBYRG9tYWluUmVxdWVzdCB3b3VsZCBmYWlsIGlmIENPUlMgaGVhZGVycyBhcmUgbm90IHNldC5cbiAgICAgICAgICAgIC8vIFRoZXJlZm9yZSwgWERvbWFpblJlcXVlc3Qgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aXRoIGNyb3NzIG9yaWdpbiByZXF1ZXN0cy5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldE9yaWdpbihsb2MpIHtcbiAgICAgICAgICAgICAgICB2YXIgYTtcbiAgICAgICAgICAgICAgICBpZiAobG9jLnByb3RvY29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYSA9IGxvYztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgICAgICAgICAgICAgIGEuaHJlZiA9IGxvYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucHJvdG9jb2wucmVwbGFjZSgvOi9nLCBcIlwiKSArIGEuaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBSZXF1ZXN0O1xuICAgICAgICAgICAgdmFyIG9yaWdpbjtcbiAgICAgICAgICAgIHZhciBvcmlnaW4yO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIFJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICBvcmlnaW4gPSBnZXRPcmlnaW4obG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIG9yaWdpbjIgPSBnZXRPcmlnaW4odXJsKTtcbiAgICAgICAgICAgICAgICBpZiAoUmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPT09IHVuZGVmaW5lZCAmJiBvcmlnaW4yICE9PSBcIlwiICYmIG9yaWdpbjIgIT09IG9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICBSZXF1ZXN0ID0gWERvbWFpblJlcXVlc3QgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFJlcXVlc3QgPSBYTUxIdHRwUmVxdWVzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVxdWVzdDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHhsaW5rTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIjtcbiAgICAgICAgY2hlY2tVc2VFbGVtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiYXNlO1xuICAgICAgICAgICAgdmFyIGJjcjtcbiAgICAgICAgICAgIHZhciBmYWxsYmFjayA9IFwiXCI7IC8vIG9wdGlvbmFsIGZhbGxiYWNrIFVSTCBpbiBjYXNlIG5vIGJhc2UgcGF0aCB0byBTVkcgZmlsZSB3YXMgZ2l2ZW4gYW5kIG5vIHN5bWJvbCBkZWZpbml0aW9uIHdhcyBmb3VuZC5cbiAgICAgICAgICAgIHZhciBoYXNoO1xuICAgICAgICAgICAgdmFyIGhyZWY7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHZhciBpblByb2dyZXNzQ291bnQgPSAwO1xuICAgICAgICAgICAgdmFyIGlzSGlkZGVuO1xuICAgICAgICAgICAgdmFyIFJlcXVlc3Q7XG4gICAgICAgICAgICB2YXIgdXJsO1xuICAgICAgICAgICAgdmFyIHVzZXM7XG4gICAgICAgICAgICB2YXIgeGhyO1xuICAgICAgICAgICAgZnVuY3Rpb24gb2JzZXJ2ZUlmRG9uZSgpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBkb25lIHdpdGggbWFraW5nIGNoYW5nZXMsIHN0YXJ0IHdhdGNoaW5nIGZvciBjaGFnbmVzIGluIERPTSBhZ2FpblxuICAgICAgICAgICAgICAgIGluUHJvZ3Jlc3NDb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgIGlmIChpblByb2dyZXNzQ291bnQgPT09IDApIHsgLy8gaWYgYWxsIHhocnMgd2VyZSByZXNvbHZlZFxuICAgICAgICAgICAgICAgICAgICB1bm9ic2VydmVDaGFuZ2VzKCk7IC8vIG1ha2Ugc3VyZSB0byByZW1vdmUgb2xkIGhhbmRsZXJzXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVDaGFuZ2VzKCk7IC8vIHdhdGNoIGZvciBjaGFuZ2VzIHRvIERPTVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGF0dHJVcGRhdGVGdW5jKHNwZWMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVbc3BlYy5iYXNlXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BlYy51c2VFbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBcInhsaW5rOmhyZWZcIiwgXCIjXCIgKyBzcGVjLmhhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWMudXNlRWwuaGFzQXR0cmlidXRlKFwiaHJlZlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWMudXNlRWwuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBcIiNcIiArIHNwZWMuaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gb25sb2FkRnVuYyh4aHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInhcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdmc7XG4gICAgICAgICAgICAgICAgICAgIHhoci5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB4LmlubmVySFRNTCA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHN2ZyA9IHguZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzdmdcIilbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdmcuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdmcuc3R5bGUud2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnLnN0eWxlLmhlaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdmcuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5pbnNlcnRCZWZvcmUoc3ZnLCBib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVJZkRvbmUoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gb25FcnJvclRpbWVvdXQoeGhyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB4aHIub250aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZUlmRG9uZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bm9ic2VydmVDaGFuZ2VzKCk7IC8vIHN0b3Agd2F0Y2hpbmcgZm9yIGNoYW5nZXMgdG8gRE9NXG4gICAgICAgICAgICAvLyBmaW5kIGFsbCB1c2UgZWxlbWVudHNcbiAgICAgICAgICAgIHVzZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInVzZVwiKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB1c2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYmNyID0gdXNlc1tpXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFpbGVkIHRvIGdldCBib3VuZGluZyByZWN0YW5nbGUgb2YgdGhlIHVzZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGJjciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBocmVmID0gdXNlc1tpXS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCB1c2VzW2ldLmdldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIFwiaHJlZlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgdXNlc1tpXS5nZXRBdHRyaWJ1dGUoXCJ4bGluazpocmVmXCIpO1xuICAgICAgICAgICAgICAgIGlmIChocmVmICYmIGhyZWYuc3BsaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gaHJlZi5zcGxpdChcIiNcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gW1wiXCIsIFwiXCJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiYXNlID0gdXJsWzBdO1xuICAgICAgICAgICAgICAgIGhhc2ggPSB1cmxbMV07XG4gICAgICAgICAgICAgICAgaXNIaWRkZW4gPSBiY3IgJiYgYmNyLmxlZnQgPT09IDAgJiYgYmNyLnJpZ2h0ID09PSAwICYmIGJjci50b3AgPT09IDAgJiYgYmNyLmJvdHRvbSA9PT0gMDtcbiAgICAgICAgICAgICAgICBpZiAoYmNyICYmIGJjci53aWR0aCA9PT0gMCAmJiBiY3IuaGVpZ2h0ID09PSAwICYmICFpc0hpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdXNlIGVsZW1lbnQgaXMgZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSByZWZlcmVuY2UgdG8gYW4gZXh0ZXJuYWwgU1ZHLCB0cnkgdG8gZmV0Y2ggaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBvcHRpb25hbCBmYWxsYmFjayBVUkwgaWYgdGhlcmUgaXMgbm8gcmVmZXJlbmNlIHRvIGFuIGV4dGVybmFsIFNWR1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmFsbGJhY2sgJiYgIWJhc2UubGVuZ3RoICYmIGhhc2ggJiYgIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gZmFsbGJhY2s7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXNbaV0uaGFzQXR0cmlidXRlKFwiaHJlZlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlc1tpXS5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBcInhsaW5rOmhyZWZcIiwgaHJlZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzY2hlZHVsZSB1cGRhdGluZyB4bGluazpocmVmXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIgPSBjYWNoZVtiYXNlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4aHIgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIHNpZ25pZmllcyB0aGF0IHByZXBlbmRpbmcgdGhlIFNWRyB3YXMgbm90IHJlcXVpcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChhdHRyVXBkYXRlRnVuYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUVsOiB1c2VzW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiBoYXNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhociA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3QoYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIgPSBuZXcgUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVtiYXNlXSA9IHhocjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9ubG9hZCA9IG9ubG9hZEZ1bmMoeGhyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBvbkVycm9yVGltZW91dCh4aHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIub250aW1lb3V0ID0gb25FcnJvclRpbWVvdXQoeGhyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oXCJHRVRcIiwgYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluUHJvZ3Jlc3NDb3VudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZVtiYXNlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhpcyBVUkwgaWYgdGhlIHVzZSBlbGVtZW50IHdhcyBub3QgZW1wdHkgYW5kIG5vIHJlcXVlc3Qgd2FzIHNlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVtiYXNlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNhY2hlW2Jhc2VdLm9ubG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IHR1cm5zIG91dCB0aGF0IHByZXBlbmRpbmcgdGhlIFNWRyBpcyBub3QgbmVjZXNzYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFib3J0IHRoZSBpbi1wcm9ncmVzcyB4aHIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVbYmFzZV0uYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGVbYmFzZV0ub25sb2FkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlW2Jhc2VdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiYXNlLmxlbmd0aCAmJiBjYWNoZVtiYXNlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChhdHRyVXBkYXRlRnVuYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlRWw6IHVzZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiBoYXNoXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1c2VzID0gXCJcIjtcbiAgICAgICAgICAgIGluUHJvZ3Jlc3NDb3VudCArPSAxO1xuICAgICAgICAgICAgb2JzZXJ2ZUlmRG9uZSgpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgd2luTG9hZDtcbiAgICAgICAgd2luTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCB3aW5Mb2FkLCBmYWxzZSk7IC8vIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICAgICAgICB0aWQgPSBzZXRUaW1lb3V0KGNoZWNrVXNlRWxlbXMsIDApO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgICAvLyBUaGUgbG9hZCBldmVudCBmaXJlcyB3aGVuIGFsbCByZXNvdXJjZXMgaGF2ZSBmaW5pc2hlZCBsb2FkaW5nLCB3aGljaCBhbGxvd3MgZGV0ZWN0aW5nIHdoZXRoZXIgU1ZHIHVzZSBlbGVtZW50cyBhcmUgZW1wdHkuXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgd2luTG9hZCwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBhZGQgYSBsaXN0ZW5lciBpZiB0aGUgZG9jdW1lbnQgaXMgYWxyZWFkeSBsb2FkZWQsIGluaXRpYWxpemUgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICB3aW5Mb2FkKCk7XG4gICAgICAgIH1cbiAgICB9XG59KCkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n");

/***/ })
/******/ ]);